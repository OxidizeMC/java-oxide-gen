use super::Difference;
use crate::{emit, io_data_err, io_data_error, prelude::*, pretty_path};
use std::{
    fs::{self, *},
    io::{self, BufRead, BufReader, Cursor, ErrorKind},
    path::Path,
};

const MARKER_COMMENT: &str =
    "WARNING:  This file was autogenerated by java-oxide.  Any changes to this file may be lost!!!";

pub fn write_generated(
    context: &emit::Context,
    path: &impl AsRef<Path>,
    contents: &[u8],
) -> io::Result<()> {
    let path: &Path = path.as_ref();
    let dir: &Path = path
        .parent()
        .ok_or_else(|| io_data_error!("{:?} has no parent directory", pretty_path!(path)))?;
    let _ = create_dir_all(dir);

    // Determine comment prefix based on file extension
    let comment_prefix: &str = match path
        .extension()
        .and_then(|ext: &std::ffi::OsStr| ext.to_str())
    {
        Some("rs") => "// ",
        Some("java") => "// ",
        Some("py") => "# ",
        Some("sh") => "# ",
        _ => "// ", // Default to // for unknown extensions
    };

    // Create content with marker comment at the top
    let marker_line: String = format!("{comment_prefix}{MARKER_COMMENT}\n");
    let full_contents: Vec<u8> = [marker_line.as_bytes(), contents].concat();

    match File::open(path) {
        Ok(file) => {
            let mut original: BufReader<File> = BufReader::new(file);
            let mut first_line: String = String::new();
            read_line_no_eol(&mut original, &mut first_line).map_err(
                |e: io::Error| -> io::Error {
                    io_data_error!(
                        "Failed to read line from file {:?}:\n{}",
                        pretty_path!(path),
                        e
                    )
                },
            )?;

            let mut found_marker: bool = false;
            for prefix in ["// ", "# "] {
                if first_line.starts_with(prefix) && (&first_line[prefix.len()..] == MARKER_COMMENT)
                {
                    found_marker = true;
                    break;
                }
            }

            if !found_marker {
                return io_data_err!(
                    "Cannot overwrite {:?}:  File exists, and first line {:?} doesn't match expected MARKER_COMMENT {:?}",
                    pretty_path!(path),
                    first_line,
                    MARKER_COMMENT
                );
            }

            match Difference::find(&mut original, &mut Cursor::new(&full_contents))? {
                None => {
                    info!("Unchanged: {:?}...", pretty_path!(path));
                    return Ok(());
                }
                Some(_) => {
                    info!("MODIFIED: {:?}", pretty_path!(path))
                }
            }
        }
        Err(ref e) if e.kind() == ErrorKind::NotFound => {
            info!("NEW: {:?}", pretty_path!(path))
        }
        Err(e) => {
            return io_data_err!("Failed to open file {:?}:\n{}", path, e);
        }
    };

    fs::write(path, &full_contents)
        .map_err(|e: io::Error| io_data_error!("Failed to write to file {:?}:\n{}", path, e))
}

fn read_line_no_eol(reader: &mut impl BufRead, buffer: &mut String) -> io::Result<usize> {
    let size: usize = reader.read_line(buffer)?;
    // FIXME: Use `buffer = buffer.trim_end().to_string()` instead?
    while buffer.ends_with('\r') || buffer.ends_with('\n') {
        buffer.pop();
    }
    Ok(size)
}
